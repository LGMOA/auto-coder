from autocoder.linters.shadow_linter import ShadowLinter
from autocoder.linters.reactjs_linter import ReactJSLinter

s = ''''
=============

WARNING: You are currently running a version of TypeScript which is not officially supported by @typescript-eslint/typescript-estree.

You may find that it works just fine, or you may not.

SUPPORTED TYPESCRIPT VERSIONS: >=3.3.1 <5.2.0

YOUR TYPESCRIPT VERSION: 5.7.2

Please only submit bug reports when using the officially supported version.

=============
[{"filePath":"/Users/allwefantasy/projects/auto-coder.web/frontend/src/components/MainContent/EditablePreviewPanel.tsx","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ')' expected.","line":285,"column":5,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport Editor from '@monaco-editor/react';\nimport Split from 'react-split';\nimport { LeftOutlined, RightOutlined, EditOutlined, SaveOutlined, EyeOutlined, LoadingOutlined, ReloadOutlined } from '@ant-design/icons';\nimport { Button, Input, message, Spin, Tooltip, Modal, Form } from 'antd'; // Added Modal, Form\nimport './PreviewPanel.css'; // Reuse existing styles if applicable, or create new ones\nimport { getLanguageByFileName } from '../../utils/fileUtils';\nimport axios from 'axios';\n\ninterface EditablePreviewPanelProps {\n  files: { path: string; content: string }[]; // Files to show in the code viewer (left panel)\n  initialUrl?: string; // Optional initial URL for the preview\n}\n\nconst EditablePreviewPanel: React.FC<EditablePreviewPanelProps> = ({ files, initialUrl = '' }) => {\n  const [activeFileIndex, setActiveFileIndex] = useState(0);\n  const [previewUrl, setPreviewUrl] = useState(initialUrl || ''); // Start empty if no initial, let fetch fill it\n  const [iframeSrc, setIframeSrc] = useState(''); // The actual URL for the iframe (proxy URL)\n  const [isUrlFocused, setIsUrlFocused] = useState(false);\n  const [isCollapsed, setIsCollapsed] = useState(false);\n  const [isEditing, setIsEditing] = useState(false);\n  const [isLoading, setIsLoading] = useState(false); // Loading state for iframe/saving\n  const [isIframeReady, setIsIframeReady] = useState(false); // Track if bridge script is ready\n  const iframeRef = useRef<HTMLIFrameElement>(null);\n  const [editingElement, setEditingElement] = useState<{ path: string; attributes: any } | null>(null); // State for element editor modal\n  const [elementForm] = Form.useForm(); // Form instance for the modal\n\n  const [debouncedPreviewUrl, setDebouncedPreviewUrl] = useState('');\n\n  // --- Fetch and Save Preview URL ---\n   useEffect(() => {\n    const fetchPreviewUrl = async () => {\n      if(initialUrl) {\n          setPreviewUrl(initialUrl); // Use prop value directly\n          return;\n      }\n      // Fetch only if not provided by prop\n      try {\n        setIsLoading(true); // Show loading while fetching URL\n        const response = await axios.get('/api/config/ui/preview-url');\n        if (response.data && response.data.preview_url) {\n          setPreviewUrl(response.data.preview_url);\n        }\n        // setPreviewUrl('http://127.0.0.1:5173');\n      } catch (error) {\n        console.error('Failed to fetch preview URL:', error);        \n      } finally {\n          // setIsLoading(false); // Loading will be stopped by iframe load later\n      }\n    };\n    fetchPreviewUrl();\n  }, [initialUrl]); // Re-run if initialUrl prop changes\n\n  // Debounce URL saving\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      // Only set debounced URL if it's different and not the initial prop value\n      if (previewUrl !== debouncedPreviewUrl && previewUrl !== initialUrl) {\n         setDebouncedPreviewUrl(previewUrl);\n      }\n    }, 1000);\n    return () => clearTimeout(timer);\n  }, [previewUrl, initialUrl, debouncedPreviewUrl]);\n\n  // Save debounced URL to backend\n  useEffect(() => {\n    // Only save if debounced URL exists, is not the default, and not the initial prop\n    if (debouncedPreviewUrl && debouncedPreviewUrl !== 'http://127.0.0.1:3000' && !initialUrl) {\n      const savePreviewUrl = async () => {\n        try {\n          console.log(\"Saving preview URL:\", debouncedPreviewUrl);\n          await axios.put('/api/config/ui/preview-url', {\n            preview_url: debouncedPreviewUrl\n          });\n        } catch (error) {\n          console.error('Failed to save preview URL:', error);\n          // Optional: message.error('Could not save preview URL preference.');\n        }\n      };\n      savePreviewUrl();\n    }\n  }, [debouncedPreviewUrl, initialUrl]);\n  // --- End Fetch and Save Preview URL ---\n\n\n  // --- Iframe Communication Logic ---\n\n  // Function to send commands to the iframe\n  const sendCommandToIframe = useCallback((command: string, payload?: any) => {\n    if (iframeRef.current && iframeRef.current.contentWindow) {\n       if (!isIframeReady && command !== 'getDOM' && command !== 'disableEditing') {\n           // Allow getDOM/disableEditing even if not fully \"ready\" but contentWindow exists\n           // Might be useful in edge cases, but generally check readiness\n           console.warn(`EditablePreviewPanel: Iframe might not be fully ready for command '${command}'.`);\n           // message.warn(`Preview might not be fully ready for command '${command}'.`);\n           // return; // Uncomment this line to strictly enforce readiness\n       }\n\n      // IMPORTANT: Specify the target origin for security\n      // This should be the origin the iframe *thinks* it has, which is our proxy origin.\n      let targetOrigin = '*'; // Default to wildcard ONLY if absolutely necessary and risks understood\n      try {\n          // Calculate origin based on the *current* iframeSrc\n          targetOrigin = new URL(iframeSrc, window.location.origin).origin;\n      } catch(e) {\n          console.error(\"Could not determine iframe target origin from src:\", iframeSrc, e);\n          message.error(\"Error determining iframe origin. Cannot send command securely.\");\n          return; // Prevent sending with '*' if calculation fails\n      }\n\n      iframeRef.current.contentWindow.postMessage({ type: 'command', command, payload }, targetOrigin);\n      console.log(`EditablePreviewPanel: Sent command '${command}' to iframe. Target Origin: ${targetOrigin}`);\n    } else {\n      console.warn(`EditablePreviewPanel: Cannot send command '${command}'. Iframe ref or contentWindow missing.`);\n      message.error(`Cannot send command '${command}'. Preview window not available.`);\n    }\n  }, [iframeSrc, isIframeReady]); // Depend on iframeSrc to get the correct targetOrigin and readiness\n\n  // Function to handle saving the DOM content\n  const saveDOM = async (htmlContent: string) => {\n    if (!htmlContent) {\n      message.error('Received empty content from preview. Cannot save.');\n      setIsLoading(false);\n      return;\n    }\n    console.log(\"EditablePreviewPanel: Received DOM content, attempting to save...\");\n    // setIsLoading(true); // Already set by requestDOM\n\n    try {\n      const response = await axios.post('/api/editable-preview/save', {\n        url: previewUrl, // The original URL that was previewed\n        html_content: htmlContent,\n      });\n      message.success(`Preview saved successfully! (ID: ${response.data.save_id})`);\n      console.log(\"Save response:\", response.data);\n      // Optionally, disable editing after save?\n      // toggleEditing(); // This would call disableEditing command\n    } catch (error: any) {\n      console.error('Failed to save edited preview:', error);\n      const errorMsg = error.response?.data?.detail || error.message || 'Unknown error saving preview.';\n      message.error(`Failed to save preview: ${errorMsg}`);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n\n  // Effect to setup message listener\n  useEffect(() => {\n    const handleMessage = (event: MessageEvent) => {\n       // IMPORTANT: Security check - verify the origin of the message\n       // It should come from the same origin as our proxy serves the iframe content\n       if (!iframeSrc) return; // Don't process if iframe source isn't set\n\n       let expectedOrigin = '';\n       try {\n           expectedOrigin = new URL(iframeSrc, window.location.origin).origin;\n       } catch (e) {\n            console.error(\"Could not determine expected origin from iframe src:\", iframeSrc, e);\n            return; // Cannot verify origin, ignore message\n       }\n\n\n       if (event.origin !== expectedOrigin) {\n         // Allow messages from 'null' origin ONLY if the iframe src is 'about:blank' initially\n         if (!(event.origin === 'null' && iframeRef.current?.getAttribute('src') === 'about:blank')) {\n             console.warn(`EditablePreviewPanel: Ignored message from unexpected origin: ${event.origin}. Expected: ${expectedOrigin}`);\n             return;\n         }\n       }\n\n      const data = event.data;\n      console.log(\"EditablePreviewPanel: Received message from iframe:\", data);\n\n      if (data && typeof data === 'object') {\n        switch (data.type) {\n          case 'status':\n            if (data.status === 'ready') {\n              setIsIframeReady(true);\n              setIsLoading(false); // Assume ready means loaded\n              console.log('EditablePreviewPanel: Iframe reported ready.');\n             // message.success('Preview loaded and ready.'); // Maybe too noisy\n              // If editing was toggled before ready, apply it now\n              if(isEditing){\n                  console.log(\"EditablePreviewPanel: Iframe ready, applying pending edit state.\");\n                  sendCommandToIframe('enableEditing');\n              }\n            }\n            break;\n          case 'domContent':\n            // Handle the received DOM content - likely save it\n            saveDOM(data.content);\n            break;\n          case 'commandResponse':\n             console.log(`EditablePreviewPanel: Received command response for '${data.command}':`, data);\n             if (!data.success) {\n                message.error(`Preview command '${data.command}' failed: ${data.error || 'Unknown error'}`);\n                // Revert state if command failed (e.g., if enableEditing failed)\n                if(data.command === 'enableEditing') setIsEditing(false);\n                if(data.command === 'disableEditing') setIsEditing(true);\n                setIsLoading(false); // Stop loading if save command failed here\n             }\n             // Optionally show success messages for commands\n             // else { message.success(`Preview command '${data.command}' successful.`); }\n            break;\n          case 'error':\n            console.error(\"EditablePreviewPanel: Error message from iframe:\", data.message);\n            message.error(`Error from preview: ${data.message}`);\n            setIsLoading(false); // Stop loading on error\n            break;\n          // Handle other message types like 'domChanged' if using MutationObserver\n          default:\n            console.log(\"EditablePreviewPanel: Unknown message type received from iframe:\", data.type);\n        }\n      }\n    };\n\n    window.addEventListener('message', handleMessage);\n\n    // Cleanup listener on component unmount\n    return () => {\n      window.removeEventListener('message', handleMessage);\n    };\n       // Added saveDOM to dependency array if it relies on state/props, but it seems self-contained\n      const data = event.data;\n      console.log(\"EditablePreviewPanel: Received message from iframe:\", data);\n\n      if (data && typeof data === 'object') {\n        switch (data.type) {\n          case 'status':\n            if (data.status === 'ready') {\n              setIsIframeReady(true);\n              setIsLoading(false); // Assume ready means loaded\n              console.log('EditablePreviewPanel: Iframe reported ready.');\n             // message.success('Preview loaded and ready.'); // Maybe too noisy\n              // If editing was toggled before ready, apply it now\n              if(isEditing){\n                  console.log(\"EditablePreviewPanel: Iframe ready, applying pending edit state.\");\n                  sendCommandToIframe('enableEditing');\n              }\n            }\n            break;\n          case 'domContent':\n            // Handle the received DOM content - likely save it\n            saveDOM(data.content);\n            break;\n          case 'elementSelected': // Handle message from bridge.js\n             if (data.path && data.attributes) {\n                openElementEditor(data.path, data.attributes);\n             } else {\n                 console.warn(\"EditablePreviewPanel: Received incomplete elementSelected message:\", data);\n                 message.warn(\"Could not get details for the selected element.\");\n             }\n             break;\n          case 'commandResponse':\n             console.log(`EditablePreviewPanel: Received command response for '${data.command}':`, data);\n             if (!data.success) {\n                message.error(`Preview command '${data.command}' failed: ${data.error || 'Unknown error'}`);\n                // Revert state if command failed (e.g., if enableEditing failed)\n                if(data.command === 'enableEditing') setIsEditing(false);\n                if(data.command === 'disableEditing') setIsEditing(true);\n                // If applyAttributes failed, maybe reopen modal or notify user?\n                if(data.command === 'applyAttributes') {\n                    // Maybe re-open modal? For now, just show error.\n                    // setEditingElement( {path: currentlyEditingPath, attributes: currentlyEditingAttrs }); // Need to store this if reopening\n                }\n                setIsLoading(false); // Stop loading if save command failed here\n             } else {\n                  // Optional: Show success messages for commands\n                  // if (data.command === 'applyAttributes') {\n                  //    message.success('Attributes applied successfully.');\n                  // }\n             }\n            break;\n          case 'error':\n            console.error(\"EditablePreviewPanel: Error message from iframe:\", data.message);\n            message.error(`Error from preview: ${data.message}`);\n            setIsLoading(false); // Stop loading on error\n            break;\n          // Handle other message types like 'domChanged' if using MutationObserver\n          default:\n            console.log(\"EditablePreviewPanel: Unknown message type received from iframe:\", data.type);\n        }\n      }\n    };\n\n    window.addEventListener('message', handleMessage);\n\n    // Cleanup listener on component unmount\n    return () => {\n      window.removeEventListener('message', handleMessage);\n    };\n       // Added previewUrl dependency for saveDOM\n  }, [sendCommandToIframe, iframeSrc, isEditing, previewUrl, saveDOM, openElementEditor]); // Added saveDOM and openElementEditor\n\n  // --- End Iframe Communication Logic ---\n\n\n  // --- URL and Iframe Loading ---\n\n  // Update iframe source when previewUrl changes and is valid\n  useEffect(() => {\n    // Basic validation\n    if (previewUrl && previewUrl.match(/^https?:\\/\\//)) {\n      // Construct the proxy URL\n      const encodedUrl = encodeURIComponent(previewUrl);\n      const proxyUrl = `/api/editable-preview/proxy?url=${encodedUrl}`;\n\n      // Only update if the proxy URL is different to prevent unnecessary reloads\n      if (proxyUrl !== iframeSrc) {\n          console.log(\"EditablePreviewPanel: Setting iframe src to:\", proxyUrl);\n          setIsLoading(true); // Set loading state when URL changes\n          setIsIframeReady(false); // Reset ready state\n          setIframeSrc(proxyUrl); // Update the src for the iframe\n           // Reset editing state when URL changes\n           if(isEditing) {\n               setIsEditing(false);\n               // No need to send disable command here, new iframe won't be editable anyway\n           }\n      }\n    } else if (!previewUrl && iframeSrc !== 'about:blank') {\n      // If URL is cleared, load blank page\n      console.log(\"EditablePreviewPanel: Clearing iframe src.\");\n      setIsLoading(false);\n      setIsIframeReady(false);\n      setIframeSrc('about:blank');\n      if(isEditing) setIsEditing(false);\n    }\n    // Intentionally not depending on iframeSrc here to avoid loop\n  }, [previewUrl, isEditing]); // Added isEditing dependency\n\n  const handleUrlChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setPreviewUrl(e.target.value);\n  };\n\n  const reloadIframe = () => {\n     if (!iframeSrc || iframeSrc === 'about:blank') {\n         message.info(\"Enter a valid URL to load the preview.\");\n         return;\n     }\n    console.log(\"EditablePreviewPanel: Reloading iframe...\");\n    setIsLoading(true);\n    setIsIframeReady(false);\n    // Reset editing state on reload\n    if(isEditing) {\n        setIsEditing(false);\n    }\n    // Force reload using the iframe's contentWindow\n    if (iframeRef.current && iframeRef.current.contentWindow) {\n       try {\n            iframeRef.current.contentWindow.location.reload();\n       } catch (e) {\n           console.error(\"Error trying to reload iframe:\", e);\n           // Fallback: Reset src with cache buster if reload fails (e.g., cross-origin issues before load)\n           const bustUrl = `${iframeSrc.split('&_cb=')[0]}&_cb=${Date.now()}`;\n           setIframeSrc(bustUrl);\n       }\n    } else {\n        console.warn(\"EditablePreviewPanel: iframe ref or contentWindow not available for reload.\");\n        // Fallback: try resetting src anyway\n        const currentSrc = iframeSrc;\n        setIframeSrc('about:blank'); // Briefly set to blank\n        setTimeout(() => setIframeSrc(currentSrc), 50); // Then set back\n    }\n     // Setting isLoading will show the spinner until the 'ready' message is received\n  };\n\n  // --- Element Editing Modal ---\n  const openElementEditor = useCallback((path: string, attributes: any) => {\n    console.log(\"Opening element editor for:\", path, attributes);\n    setEditingElement({ path, attributes });\n    // Reset form fields when opening\n    elementForm.resetFields();\n    // Set initial values after a short delay to ensure modal is rendered\n    setTimeout(() => {\n       elementForm.setFieldsValue(attributes || {});\n    }, 50);\n  }, [elementForm]); // Include elementForm in dependencies\n\n  const handleModalCancel = () => {\n    setEditingElement(null);\n    elementForm.resetFields();\n  };\n\n  const applyAttributes = (xpath: string, attributes: any) => {\n     // Filter out empty/null values before sending? Or let bridge handle it?\n     // Let's keep it simple and send all form values for now.\n     console.log(\"Applying attributes:\", xpath, attributes);\n     sendCommandToIframe('applyAttributes', { xpath, attributes });\n     handleModalCancel(); // Close modal after applying\n   };\n\n  const handleFormFinish = (values: any) => {\n    if (editingElement) {\n      applyAttributes(editingElement.path, values);\n    }\n  };\n  // --- End Element Editing Modal ---\n\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      // Trigger reload or update based on current URL vs input value?\n      // For now, just reload the current iframeSrc derived from previewUrl state\n      reloadIframe();\n    }\n  };\n\n  // --- Editing Actions ---\n\n  const toggleEditing = () => {\n    if (!isIframeReady) {\n      message.warn('Preview is not ready yet. Cannot toggle editing.');\n      return;\n    }\n    const newState = !isEditing;\n    // Send command first\n    sendCommandToIframe(newState ? 'enableEditing' : 'disableEditing');\n    // Update state optimistically - message listener will correct if command fails\n    setIsEditing(newState);\n    message.info(newState ? 'Editing enabled' : 'Editing disabled');\n  };\n\n  const requestDOM = () => {\n    if (!isIframeReady) {\n      message.warn('Preview is not ready yet. Cannot save.');\n      return;\n    }\n    // Allow saving even if not actively editing? UX Decision.\n    // Let's require editing mode to be ON to save, avoids accidental saves of pristine state.\n    if (!isEditing) {\n       message.info('Enable editing mode first before saving changes.');\n       return;\n    }\n\n    console.log(\"EditablePreviewPanel: Requesting DOM content from iframe...\");\n    setIsLoading(true); // Show loading spinner while waiting for DOM\n    message.loading({ content: 'Getting content from preview...', key: 'getDOM' }); // Show antd loading message\n    sendCommandToIframe('getDOM');\n\n    // Add a timeout in case the iframe doesn't respond\n    setTimeout(() => {\n        if (isLoading) { // Check if still loading after timeout\n             message.destroy('getDOM');\n             message.error('Timeout waiting for content from preview.');\n             setIsLoading(false);\n        }\n    }, 10000); // 10 second timeout\n  };\n\n  // --- Render Logic ---\n  const currentFile = files && files.length > activeFileIndex ? files[activeFileIndex] : null;\n\n  return (\n    <div className=\"flex flex-col\" style={{ height: '650px' }}>\n      <div className=\"flex-1 overflow-hidden\">\n        <Split\n          className=\"split-container\"\n          sizes={(isCollapsed && [0, 100]) || [50, 50]} // Collapse left panel fully\n          minSize={(isCollapsed && 0) || 200}\n          expandToMin={false}\n          gutterSize={8}\n          snapOffset={30}\n          dragInterval={1}\n          direction=\"horizontal\"\n          cursor=\"col-resize\"\n          style={{ display: 'flex', flexDirection: 'row', height: '100%' }}\n        >\n          {/* Left Panel - Code Preview */}\n           <div className={`flex flex-col relative ${isCollapsed ? 'hidden' : ''}`}>\n            {(files.length === 0 && (\n              <div className=\"w-full h-full flex items-center justify-center text-gray-400\">\n                No code changes to display\n              </div>\n            )) || (\n              <>\n                <div className=\"flex bg-gray-800 border-b border-gray-700 overflow-x-auto\">\n                  {files.map((file, index) => (\n                    <button\n                      key={file.path}\n                      className={`px-4 py-2 text-sm whitespace-nowrap ${\n                        (index === activeFileIndex && 'bg-gray-700 text-white') || 'text-gray-300 hover:bg-gray-600'\n                      }`}\n                      onClick={() => setActiveFileIndex(index)}\n                      title={file.path}\n                    >\n                      {file.path.split('/').pop()}\n                    </button>\n                  ))}\n                </div>\n                <div className=\"flex-1 h-full\">\n                  {currentFile ? (\n                    <Editor\n                      height=\"100%\" // Ensure editor takes full height\n                      language={getLanguageByFileName(currentFile.path)}\n                      theme=\"vs-dark\"\n                      value={currentFile.content}\n                      options={{\n                        readOnly: true,\n                        minimap: { enabled: true },\n                        fontSize: 14,\n                        lineNumbers: 'on',\n                        folding: true,\n                        automaticLayout: true, // Important for resizing\n                      }}\n                    />\n                  ) : (\n                     <div className=\"w-full h-full flex items-center justify-center text-gray-400\">\n                        Select a file to view its content\n                     </div>\n                  )}\n                </div>\n              </>\n            )}\n          </div>\n\n\n          {/* Right Panel - Editable Web Preview */}\n          <div className=\"flex flex-col border-l border-gray-700 relative\">\n             {/* Collapse/Expand Toggle Button */}\n             <Tooltip title={isCollapsed ? \"Show Code\" : \"Hide Code\"}>\n                <button\n                  onClick={() => setIsCollapsed(!isCollapsed)}\n                  className=\"absolute left-0 top-1/2 transform -translate-x-full -translate-y-1/2 z-20\n                            bg-gray-700 rounded-l-md p-1 hover:bg-gray-600 transition-colors\"\n                  style={{ marginLeft: '-1px' }} // Adjust position slightly over the gutter\n                 >\n                  {(isCollapsed && <RightOutlined />) || <LeftOutlined />}\n                </button>\n             </Tooltip>\n\n            {/* URL Input and Controls Bar */}\n            <div className=\"p-2 bg-gray-800 border-b border-gray-700 flex items-center space-x-2\">\n              <div className={`flex-grow flex items-center px-2 py-1 bg-gray-900 rounded-lg border ${(isUrlFocused && 'border-blue-500') || 'border-gray-700'}`}>\n                 {/* Loading indicator inside URL bar */}\n                 {isLoading && <Spin size=\"small\" className=\"px-1 text-gray-400\" />}\n                 {!isLoading && <EyeOutlined className=\"px-1 text-gray-400\" />} {/* Placeholder icon */}\n\n                <input\n                  type=\"url\"\n                  value={previewUrl}\n                  onChange={handleUrlChange}\n                  onKeyDown={handleKeyDown}\n                  onFocus={() => setIsUrlFocused(true)}\n                  onBlur={() => setIsUrlFocused(false)}\n                  className=\"flex-1 px-2 py-1 bg-transparent text-white text-sm focus:outline-none\"\n                  placeholder=\"Enter URL to preview (e.g., http://localhost:3000)\"\n                  disabled={isLoading} // Disable input while loading\n                />\n                <Tooltip title=\"Reload Preview\">\n                    <button\n                      onClick={reloadIframe}\n                      className=\"px-2 text-gray-400 hover:text-white disabled:text-gray-600\"\n                      disabled={isLoading || !iframeSrc || iframeSrc === 'about:blank'}\n                     >\n                       <ReloadOutlined />\n                    </button>\n                </Tooltip>\n              </div>\n               {/* Edit and Save Buttons */}\n               <Tooltip title={isEditing ? \"Disable Editing\" : \"Enable Editing\"}>\n                  <Button\n                    icon={<EditOutlined />}\n                    onClick={toggleEditing}\n                    type={isEditing ? \"primary\" : \"default\"}\n                    disabled={!isIframeReady || isLoading} // Disable if not ready or loading\n                    ghost={!isEditing} // Make it ghost when not active\n                  />\n               </Tooltip>\n               <Tooltip title=\"Save Edited HTML\">\n                  <Button\n                    icon={<SaveOutlined />}\n                    onClick={requestDOM}\n                    disabled={!isEditing || !isIframeReady || isLoading} // Must be editing and ready\n                  />\n               </Tooltip>\n            </div>\n\n             {/* Iframe Container */}\n            <div className=\"flex-1 relative bg-gray-900\">\n              {isLoading && (\n                <div className=\"absolute inset-0 flex items-center justify-center z-10 bg-gray-900 bg-opacity-75\">\n                  <Spin size=\"large\" tip=\"Loading Preview...\" />\n                </div>\n              )}\n              {(iframeSrc && iframeSrc !== 'about:blank') ? (\n                <iframe\n                  ref={iframeRef}\n                  src={iframeSrc}\n                  title=\"Editable Preview\"\n                  width=\"100%\"\n                  height=\"100%\"\n                  className={`border-0 transition-opacity duration-300 ${isLoading ? 'opacity-50' : 'opacity-100'}`}\n                  // IMPORTANT Sandbox attributes:\n                  // allow-scripts: Needed for the bridge script and the page's own JS.\n                  // allow-same-origin: Crucial! Allows the script inside the iframe (served from our proxy) to communicate back via postMessage, treating it as same-origin relative to the proxy endpoint. It does NOT make it same-origin with the parent window. Also needed for scripts within the iframe to potentially access their own origin's resources if they make requests.\n                  // allow-forms: If the page has forms.\n                  // allow-popups, allow-modals: If the page uses these features.\n                  // allow-top-navigation: Risky, allows iframe to potentially navigate the top window. Consider removing if not needed. Use 'allow-top-navigation-by-user-activation' for slightly more safety. Or 'allow-popups-to-escape-sandbox'.\n                  sandbox=\"allow-scripts allow-same-origin allow-forms allow-popups allow-modals\"\n                  onError={(e) => {\n                      console.error(\"Iframe loading error event:\", e);\n                      message.error('Failed to load the preview content. Check the URL and browser console.');\n                      setIsLoading(false); // Stop loading on error\n                      setIsIframeReady(false);\n                  }}\n                  onLoad={() => {\n                      console.log(\"EditablePreviewPanel: Iframe onLoad event fired.\");\n                      // The 'ready' message from the bridge script is a more reliable indicator\n                      // but onLoad can signal the basic frame structure is loaded.\n                      // Setting isLoading(false) here might be too early if the bridge isn't ready.\n                      // Rely on the 'ready' message from the bridge script instead.\n                      // setIsLoading(false);\n                  }}\n                />\n              ) : (\n                <div className=\"h-full flex items-center justify-center text-gray-400\">\n                  { previewUrl ? 'Loading preview...' : 'Enter a URL above to start the preview' }\n                </div>\n              )}\n            </div>\n          </div>\n         </Split>\n       </div>\n\n       {/* Element Attribute Editor Modal */}\n        <Modal\n          title=\"Edit Element Attributes\"\n          open={!!editingElement} // Use 'open' instead of 'visible' for newer AntD versions\n          onCancel={handleModalCancel}\n          footer={null} // Remove default footer if using Form's button\n          destroyOnClose // Reset form state when modal is closed\n          maskClosable={false} // Prevent closing by clicking outside\n        >\n          {editingElement && (\n            <Form\n              form={elementForm}\n              layout=\"vertical\"\n              // initialValues={editingElement.attributes} // Set dynamically in openElementEditor\n              onFinish={handleFormFinish} // Use Form's onFinish\n              // onFinishFailed={(errorInfo) => { console.log('Failed:', errorInfo); }} // Optional: Handle validation errors\n            >\n              <Form.Item\n                 label=\"XPath (Readonly)\"\n                 name=\"_xpath_\" // Use a dummy name or just display text\n              >\n                 <Input.TextArea value={editingElement.path} readOnly rows={2} style={{ cursor: 'default', color: '#aaa' }} />\n              </Form.Item>\n              <Form.Item\n                label=\"ID\"\n                name=\"id\"\n                rules={[{ required: false }]} // Adjust rules as needed\n              >\n                <Input placeholder=\"Element ID (optional)\" />\n              </Form.Item>\n              <Form.Item\n                label=\"Class\"\n                name=\"class\"\n                rules={[{ required: false }]}\n              >\n                <Input placeholder=\"CSS classes (space-separated)\" />\n              </Form.Item>\n              <Form.Item\n                label=\"Style\"\n                name=\"style\"\n                rules={[{ required: false }]}\n              >\n                <Input.TextArea rows={4} placeholder=\"Inline CSS styles (e.g., color: red;)\" />\n              </Form.Item>\n              {/* Add other attributes here if needed */}\n              <Form.Item>\n                <Button type=\"primary\" htmlType=\"submit\" loading={isLoading}>\n                  Apply Changes\n                </Button>\n                <Button style={{ marginLeft: 8 }} onClick={handleModalCancel}>\n                  Cancel\n                </Button>\n              </Form.Item>\n            </Form>\n          )}\n        </Modal>\n\n     </div>\n   );\n };\n\nexport default EditablePreviewPanel;","usedDeprecatedRules":[{"ruleId":"dot-location","replacedBy":[]},{"ruleId":"new-parens","replacedBy":[]},{"ruleId":"no-mixed-operators","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"no-whitespace-before-property","replacedBy":[]},{"ruleId":"rest-spread-spacing","replacedBy":[]}]}]
'''

result = {
            'success': False,
            'framework': 'reactjs',
            'files_analyzed': 0,
            'error_count': 0,
            'warning_count': 0,
            'issues': []
        }

project_path = "/Users/allwefantasy/projects/auto-coder.web/frontend"
linter = ReactJSLinter()
# v = linter._convert_raw_lint_result_to_dict(s,result,project_path)
# print(result)

v = linter.lint_file(file_path="/Users/allwefantasy/projects/auto-coder.web/frontend/src/components/MainContent/EditablePreviewPanel.tsx",project_path="/Users/allwefantasy/projects/auto-coder.web/frontend")

print(v)

