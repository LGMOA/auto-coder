# 036-AutoCoder_编码prompt实践_1

在使用 AutoCoder 编程中，其实存在两个大的阶段：

1. 根据你的需求查找文件。
2. 把这些文件作为上下文，然后结合需求，生成代码然后合并到源文件中。

今天我们重点讲讲，如何让大模型找到你的文件并且应该如何描述你的需求从而达到最佳的生成效果。

## 如何让 AutoCoder 更好的找到需要的代码文件

第一阶段要求我们至少能找到：

1. 要修改的文件
2. 为了能够修改这些文件，我们还需要依赖哪些其他文件。

这个时候我们在写需求的时候，就有些技巧了，下面是一个来自AutoCoder 的实际案例：

```yaml
include_file: 
   - ./common/diff.yml

query: |   
   在 code_auto_generate 开头的文件里，我们需要检测下 llm 是不是有个 code_model 值存在。参考 
   rest.py 中检测 vl_model 的方式。如果 code_model存在，那么我们需要使用 code_model 而不是模型的llm 来处理。
   
```

这个其实是我蛮得意的一个写法。简单的一两行字里，我们提供了三个信息：

1. 需要修改的文件是什么
2. 修改逻辑是什么
3. 具体的修改范例是什么

一般而言，我们在实际使用过程中，1 是一定要提及的。 2，3 中的3是可选的。 如果2 写的够详细，那么就不需要3。 如果你的修改是有返利的，最好就能
告诉AutoCoder 这个已经写过的逻辑是什么。

从这个例子中，我们可以可以看到 AutoCoder 的高效率，我们只要描述上面三个点，就可以在无需我们自己打开一个代码文件的情况，自动精准的完成
所有的代码修改。

### 需要修改的文件是什么

这里我们们用了几个技巧：

1. 显式的告诉 AutoCoder 我们需要的文件的名字是 `code_auto_generate` 开头的文件里，这样正常情况下 AutoCoder 就能找到这几个需要修改的文件了，这里应该是 `code_auto_generate.py`, `code_auto_generat_diff.py` 以及 `code_auto_generate_strict_diff.py` 这几个文件。
2. 你可以通过提及文件部分路径来更精确的定位，比如 `common/__init__.py` 这样的提法。
3. 你可以通过函数名来定位，然后辅助一些代码来定位。函数名可以帮你快速找到文件，辅助代码可以让你更清晰的控制修改的范围。这个对于前端特别有用，比如我希望在那个form input 后面再加一个input框，这样就可以非常精准新增一个输入框了。

此外，你还可以专门提某个文件，并且显示说，需要把这个文件依赖到的文件都找出来（能不能最后找出来就看大模型的智能程度了）。
当然最后依然可能会遇到难处，就是你怎么说，AutoCoder就是没get到你的意思，这个时候你可以显示的写路径或者通过 `urls` 参数来指定文件路径，确保该文件一定
被引用。

### 你的需求（修改逻辑）应该如何描述

修改逻辑一般通过三种方式来表达：

1. 给定一个比较大概的修改描述，但是具体实现细节有以前的代码可以参考。
2. 给定详细的修改逻辑，手把手教。
3. 给定一个目标，然后简单描述一下，让 AutoCoder 自己去实现。

此外，对于第二种情况，如果你自己一时讲不清楚，你也可以分多个步骤来迭代，每次改一点，最终通过多次来完成最后的业务逻辑实现。前面我给的案例，就是
一个经典的 1 的方案，告诉你逻辑，以及参考例子，大模型很精确的完成了需求。

对于第二种情况，我们另外一个实际的例子：

```yaml
enable_rag_search: | 
   byzerllm  使用 openai_tts模型的 python 代码

query: | 
   我们要在 audio.py 中实现一个新的类叫 PlayStreamAudioFromText，
   该类有一个方法 run,
   该方法输入是一个字符串generator，在方法内部会将文本转换为语音，并且播放出来。
   
   具体逻辑是：
   1. PlayStreamAudioFromText 维护一个queue，一个线程池
   1. 运行时，从generator中读取文本，然后将文本放入queue中
   2. 从queue中取出文本，按中英文句号或者换行符对语句进行切割调用，
      并行调用 openai_tts 模型将文本转换为语音，保存在 /tmp/wavs 目录下。
      音频文件用 001.wav, 002.wav, 003.wav...的命名规则保存在一个目录下.
   3. 使用一个独立的线程播放音频文件，播放完一个音频文件后，再播放下一个音频文件，直到播放完毕。
```

这里我们把业务逻辑写的相当详细，这样 AutoCoder 就能和你可控的完成这个需求了，而不是他自由发挥。此外，这里我们也用了 RAG 的方式
从文档里召回一些示例代码，这样避免我们在写query的时候，自己手动添加这些示例代码。

第三种情况，给定目标这个，我们也来看一个例子：

```yaml
query: |
  在 auto_coder.py 中添加一个 revert 子命令。
  命令具体形态如下：
  
  ```shell
  auto_coder revert --file {args.file}
  ```

  具体逻辑：

  0. 使用Python git 包而不是使用shell命令，revert 功能放到 git_utils.py 中。
  1. 找到 git message 等于 {args.file}的 git log,并 找到对应的 commit id。
  2. 使用 git revert {commit_id} 撤销对应的 commit。
  3. 如果撤销失败，需要打印 warning 信息。
```

在这个例子里，就是典型的，我先告诉你我要达到的一个效果是啥，接着我们给你加一些限制或者逻辑，从而在可控和大模型的自由发挥之间取得一个平衡。

## 总结

使用 AutoCoder 过程中，基本套路是上面描述的，尽量告知需要的文件有哪些，根据实际情况描述你的修改需求，因为是基于
已有项目的，所以我们无需描述采用的技术等各种细节，只需要描述我们的需求即可。

大家也可以多看看 AutoCoder  actions目录下的例子，里面都是实际的例子，可以帮助你更好的理解如何写需求。