{{ query }}

先做一个完整的需求设计，放在 docs/jobs/design.md 文件中。
design.md 文件必须包含以下四个部分，每个部分都要有详细的内容。

---

### 1. 接口使用说明

**设计要求：**
- 分析用户需求，提取核心功能点
- 设计简洁易用的API接口
- 提供完整的使用示例代码
- 展示用户最常见的使用场景

**设计思路：**
1. 理解用户要解决的核心问题
2. 设计符合用户心智模型的API
3. 优先考虑易用性和直观性
4. 提供清晰的使用示例

**输出格式：**
```python
# 导入和初始化示例
from your_package import YourMainClass

# 基础使用示例
client = YourMainClass(
    # 必要的配置参数
    config_param="value"
)

# 核心功能使用示例1
result1 = client.main_function(
    param1="value1",
    param2="value2"
)

# 核心功能使用示例2  
result2 = client.another_function(
    different_param="value"
)

# 高级功能使用示例
advanced_result = client.advanced_function(
    complex_param={
        "nested": "structure"
    },
    stream=True
)

# 处理结果的典型方式
for item in advanced_result:
    print(item)
```

---

### 2. 单元测试设计

**设计要求：**
- 基于第1部分的接口设计，为每个功能点设计测试用例
- 包含正常流程测试、异常情况测试、边界条件测试
- 使用Given-When-Then格式描述测试场景
- 合理使用mock避免外部依赖

**设计思路：**
1. 为每个公开接口设计对应的测试类
2. 覆盖所有可能的使用场景和错误情况
3. 测试用例要独立、可重复、快速执行
4. 重点测试接口行为而非实现细节

**输出格式：**
```python
import pytest
from unittest.mock import Mock, patch
from your_package import YourMainClass

class TestYourMainClass:
    
    @pytest.fixture
    def client(self):
        """测试客户端fixture
        Given: 需要一个配置好的客户端实例
        When: 使用有效配置创建客户端
        Then: 返回可用的客户端实例
        """
        return YourMainClass(config_param="test-value")
    
    def test_initialization_success(self):
        """测试成功初始化
        Given: 有效的配置参数
        When: 创建客户端实例
        Then: 客户端应该正确初始化，配置参数应该被设置
        """
        # 测试实现
    
    def test_main_function_success(self, client):
        """测试主要功能成功执行
        Given: 有效的客户端和正确的参数
        When: 调用主要功能方法
        Then: 应该返回预期的结果
        """
        # 测试实现
    
    def test_main_function_invalid_params(self, client):
        """测试无效参数处理
        Given: 有效的客户端但无效的参数
        When: 调用主要功能方法
        Then: 应该抛出参数验证错误
        """
        # 测试实现
    
    def test_error_handling(self, client):
        """测试错误处理
        Given: 模拟的错误条件
        When: 执行操作遇到错误
        Then: 应该抛出相应的异常类型
        """
        # 测试实现
    
    def test_edge_cases(self, client):
        """测试边界条件
        Given: 边界值输入
        When: 执行相关操作
        Then: 应该正确处理边界情况
        """
        # 测试实现
```

---

### 3. 业务代码实现设计

**设计要求：**
- 基于功能需求，设计清晰的模块划分和目录结构
- 明确各功能模块的职责分工和依赖关系
- 考虑代码的可维护性、可扩展性和测试友好性

**设计思路：**
1. 按功能职责划分模块，避免耦合
2. 设计清晰的目录结构，便于理解和维护
3. 明确模块间的依赖关系，避免循环依赖
4. 考虑未来扩展的可能性

**输出格式：**

**项目目录结构：**
```
your_package/
├── __init__.py                 # 包入口，导出主要接口
├── main_module.py              # 主要功能模块
├── config.py                   # 配置管理
├── exceptions.py               # 异常类定义
├── models/                     # 数据模型
│   ├── __init__.py
│   ├── base.py                # 基础模型类
│   ├── request.py             # 请求模型
│   └── response.py            # 响应模型
├── core/                       # 核心功能模块
│   ├── __init__.py
│   ├── processor.py           # 核心处理逻辑
│   └── validator.py           # 数据验证
├── adapters/                   # 适配器层
│   ├── __init__.py
│   ├── external_api.py        # 外部API适配
│   └── storage.py             # 存储适配
├── utils/                      # 工具模块
│   ├── __init__.py
│   ├── helpers.py             # 辅助函数
│   └── constants.py           # 常量定义
└── tests/                      # 测试目录
    ├── __init__.py
    ├── conftest.py            # pytest配置
    ├── test_main.py           # 主要功能测试
    ├── test_models.py         # 模型测试
    └── test_core.py           # 核心功能测试
```

**核心模块划分：**

#### 1. 主要功能模块 (main_module.py)
**职责：**
- 提供对外的主要接口
- 协调各子模块的工作
- 处理用户输入和输出

#### 2. 异常处理模块 (exceptions.py)
**职责：**
- 定义所有自定义异常类
- 提供错误码和异常的映射关系
- 统一异常处理策略

#### 3. 数据模型模块 (models/)
**职责：**
- 定义数据结构和验证规则
- 提供数据序列化和反序列化方法
- 处理数据转换逻辑

#### 4. 核心功能模块 (core/)
**职责：**
- 实现核心业务逻辑
- 处理数据验证和转换
- 独立于外部依赖的纯业务逻辑

#### 5. 适配器模块 (adapters/)
**职责：**
- 处理外部系统集成
- 抽象外部依赖
- 提供统一的接口给核心模块

#### 6. 工具模块 (utils/)
**职责：**
- 提供通用的辅助函数
- 定义项目常量
- 处理通用的工具方法

#### 7. 配置模块 (config.py)
**职责：**
- 管理应用配置
- 支持环境变量和文件配置
- 提供配置验证功能

**模块依赖关系：**
```
main_module.py
├── core/ (核心功能)
│   ├── models/ (数据模型)
│   └── adapters/ (适配器)
├── config.py (配置)
├── exceptions.py (异常)
└── utils/ (工具函数)
```

---

### 4. 分阶段实现计划

**设计要求：**
- 将整个实现分解为多个独立的开发阶段
- 每个阶段都有明确的目标和可测试的交付物
- 每个阶段内部可以进一步分解为具体的开发步骤

**设计思路：**
1. 按依赖关系和重要性排序开发阶段
2. 每个阶段都要有可验证的输出
3. 优先实现核心功能，再完善周边特性
4. 确保每个阶段结束后系统仍然可用

**输出格式：**

#### 阶段1：基础框架搭建
**目标：** 建立项目基础架构和核心接口
**步骤：**
1. 创建项目目录结构和基础文件
2. 定义核心异常类和数据模型
3. 实现基础配置管理功能
4. 搭建单元测试框架
5. 完成主要接口的框架代码

**验收标准：**
- 项目结构完整，所有模块可以正常导入
- 基础测试框架可以运行
- 核心接口可以调用（即使功能未完成）

#### 阶段2：核心功能实现
**目标：** 实现主要业务逻辑和核心功能
**步骤：**
1. 实现核心处理模块
2. 完成数据验证和转换逻辑
3. 实现主要功能接口
4. 编写核心功能的单元测试
5. 确保基本功能流程可以正常工作

**验收标准：**
- 核心功能完整可用
- 单元测试覆盖主要功能点
- 基本的错误处理机制正常工作

#### 阶段3：外部集成和适配
**目标：** 实现外部系统集成和数据适配
**步骤：**
1. 实现外部API适配器
2. 完成存储和持久化逻辑
3. 实现数据格式转换
4. 添加集成测试
5. 处理外部依赖的错误场景

**验收标准：**
- 外部系统集成正常工作
- 数据持久化功能完整
- 集成测试通过
- 外部依赖错误处理完善

#### 阶段4：完善和优化
**目标：** 完善功能特性和性能优化
**步骤：**
1. 添加高级功能特性
2. 优化性能和内存使用
3. 完善错误处理和日志记录
4. 添加更多配置选项
5. 进行端到端测试

**验收标准：**
- 所有功能特性完整
- 性能指标满足要求
- 错误处理和日志完善
- 端到端测试通过

#### 阶段5：文档
**目标：** 完善文档和发布准备工作
**步骤：**
在模块的第一层级目录添加一个README.md文件,展示用户接口的使用案例。

## 设计注意事项

1. **用户需求理解**：深入理解用户的真实需求，而不只是表面的功能要求
2. **接口设计优先**：优先设计好用户接口，再考虑内部实现
3. **测试驱动开发**：严格遵循TDD原则，先写测试再写实现
4. **模块化设计**：保持模块间的低耦合和高内聚
5. **通过用户接口测试来确保业务逻辑准确性**：严格通过对用户接口的测试来确认一个模块是正确实现。
